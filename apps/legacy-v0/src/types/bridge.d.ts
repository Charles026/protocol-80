/**
 * Typst Worker Bridge Protocol (Unified Protocol v2.0)
 * 
 * Strict discriminated union types for Main Thread ↔ Worker communication.
 * No `any` types allowed. All messages use `kind` discriminator.
 * 
 * IMPORTANT: This is the SINGLE SOURCE OF TRUTH for all Worker communication.
 * Do NOT define parallel protocols elsewhere.
 * 
 * @module bridge
 */

// ============================================================================
// Exhaustiveness Check Utility
// ============================================================================

/**
 * Exhaustiveness check helper for switch statements
 * 
 * @throws Error if called at runtime (indicates missing switch case)
 * @example
 * ```typescript
 * switch (msg.kind) {
 *   case 'INIT': // ...
 *   case 'COMPILE': // ...
 *   default:
 *     assertNever(msg, `Unknown message kind: ${(msg as any).kind}`)
 * }
 * ```
 */
export function assertNever(x: never, message?: string): never {
    throw new Error(message ?? `Unexpected discriminated union member: ${JSON.stringify(x)}`)
}

// ============================================================================
// Worker FSM States
// ============================================================================

/**
 * Finite State Machine states for the Worker Supervisor
 */
export type WorkerState =
    | 'BOOTING'     // Worker loading, Wasm initializing
    | 'IDLE'        // Ready to accept commands
    | 'BUSY'        // Processing compilation
    | 'CRASHED'     // Worker died (panic/error)
    | 'RECOVERING'  // Phoenix Protocol in progress

// ============================================================================
// Outline / Semantic Extraction Types
// ============================================================================

/**
 * Document heading item
 * Generated by Typst query(heading)
 */
export interface OutlineHeading {
    /** Heading level (1-6) */
    readonly level: number
    /** Heading text content */
    readonly body: string
    /** Page number (1-based) */
    readonly page: number
    /** Y coordinate (pt) for in-page positioning */
    readonly y: number
}

/**
 * Document figure item
 * Generated by Typst query(figure)
 */
export interface OutlineFigure {
    /** Figure type (image, table, raw, etc.) */
    readonly kind: string
    /** Figure caption/description */
    readonly caption: string
    /** Figure number */
    readonly number: number
    /** Page number (1-based) */
    readonly page: number
    /** Y coordinate (pt) for in-page positioning */
    readonly y: number
}

/**
 * Document outline data
 * Contains headings, figures, and other structural information
 */
export interface OutlineData {
    /** All headings */
    readonly headings: readonly OutlineHeading[]
    /** All figures */
    readonly figures: readonly OutlineFigure[]
    /** Total page count */
    readonly pageCount: number
}

// ============================================================================
// Source Probe Types (Protocol 80 MVP)
// ============================================================================

/**
 * Physical location in Typst document
 * Coordinates are in Points (pt), where 1 inch = 72 pt
 */
export interface ProbeLocation {
    /** Page number (1-based) */
    readonly page: number
    /** X coordinate in points from page left edge */
    readonly x: number
    /** Y coordinate in points from page top edge */
    readonly y: number
}

/**
 * Probe type discriminator
 * - geo: Physical coordinate markers
 * - struct: Logical structure boundaries
 * - semantic: AI-generated metadata
 */
export type ProbeType = 'geo' | 'struct' | 'semantic'

/**
 * Anchor type for geo probes
 * - point: Single position marker
 * - start: Beginning of a region
 * - end: End of a region
 */
export type ProbeAnchor = 'point' | 'start' | 'end'

/**
 * Edge type for struct probes
 */
export type ProbeEdge = 'start' | 'end'

/**
 * Base probe interface - common fields for all probe types
 */
export interface ProbeBase {
    /** Probe type discriminator */
    readonly type: ProbeType
    /** Unique identifier (UUID v4 or "L{line}-C{col}" format) */
    readonly id: string
    /** Physical location (populated at layout time) */
    readonly loc: ProbeLocation
    /** Sequence number for ordering */
    readonly seq: number
    /** Protocol version */
    readonly _v: string
}

/**
 * Geo Probe - Physical coordinate marker
 * Used for RAG, visual highlighting, click-to-source mapping
 */
export interface GeoProbe extends ProbeBase {
    readonly type: 'geo'
    /** Anchor semantics */
    readonly anchor: ProbeAnchor
    /** Optional tags for filtering */
    readonly tags?: readonly string[]
}

/**
 * Struct Probe - Logical structure boundary marker
 * Used for outline generation, section navigation
 */
export interface StructProbe extends ProbeBase {
    readonly type: 'struct'
    /** Structure kind (section, chapter, heading, figure, etc.) */
    readonly kind: string
    /** Hierarchical level (1 for h1, 2 for h2, etc.) */
    readonly level: number
    /** Boundary edge */
    readonly edge: ProbeEdge
    /** Optional title/label */
    readonly title?: string
}

/**
 * Semantic Probe - AI metadata injection
 * Used for audit trails, generation tracking
 */
export interface SemanticProbe extends ProbeBase {
    readonly type: 'semantic'
    /** Arbitrary metadata payload */
    readonly data: Record<string, unknown>
}

/**
 * Union type for all probe types
 */
export type Probe = GeoProbe | StructProbe | SemanticProbe

/**
 * Probe data collection
 * Returned by probe query after compilation
 */
export interface ProbeData {
    /** Protocol version */
    readonly version: string
    /** Total probe count */
    readonly count: number
    /** All probes in document order */
    readonly probes: readonly Probe[]
    /** Document total page count */
    readonly pageCount?: number
}

// ============================================================================
// Inbound Messages (Main Thread → Worker)
// ============================================================================

/**
 * Initialize the compiler with font data
 */
export interface InitMessage {
    readonly kind: 'INIT'
    /** Font bundle as ArrayBuffer (Transferable) */
    readonly fonts?: ArrayBuffer
}

/**
 * Compile Typst source code
 */
export interface CompileMessage {
    readonly kind: 'COMPILE'
    /** Typst source code */
    readonly source: string
    /** Unique request identifier for matching responses */
    readonly requestId: string
    /** Main file path (default: /main.typ) */
    readonly mainFilePath?: string
    /** Output format */
    readonly format?: 'vector' | 'pdf'
}

/**
 * Heartbeat ping for deadlock detection
 */
export interface HeartbeatMessage {
    readonly kind: 'HEARTBEAT'
    /** Timestamp when heartbeat was sent */
    readonly timestamp: number
}

/**
 * Reset compiler state (clear caches, shadow filesystem)
 */
export interface ResetMessage {
    readonly kind: 'RESET'
    readonly requestId: string
}

/**
 * Gracefully dispose the compiler
 */
export interface DisposeMessage {
    readonly kind: 'DISPOSE'
}

/**
 * Discriminated union of all inbound message types
 */
export type MainToWorkerMessage =
    | InitMessage
    | CompileMessage
    | HeartbeatMessage
    | ResetMessage
    | DisposeMessage

// ============================================================================
// Outbound Messages (Worker → Main Thread)
// ============================================================================

/**
 * Worker has finished booting and is ready
 */
export interface ReadyMessage {
    readonly kind: 'READY'
}

/**
 * Compilation completed successfully
 * 
 * @remarks
 * The `artifact` Uint8Array should be transferred (zero-copy) using
 * postMessage's transferable objects: `postMessage(msg, [artifact.buffer])`
 */
export interface CompileSuccessMessage {
    readonly kind: 'COMPILE_SUCCESS'
    /** Compiled artifact (Transferable via ArrayBuffer) */
    readonly artifact: Uint8Array
    /** Compilation time in milliseconds */
    readonly timing: number
    /** Match to original request */
    readonly requestId: string
    /** Diagnostic messages (warnings, hints) */
    readonly diagnostics?: DiagnosticInfo[]
}

/**
 * Compilation failed with recoverable error
 */
export interface CompileErrorMessage {
    readonly kind: 'COMPILE_ERROR'
    /** Error description */
    readonly error: string
    /** Match to original request */
    readonly requestId: string
    /** Diagnostic messages */
    readonly diagnostics?: DiagnosticInfo[]
}

/**
 * Unrecoverable Wasm panic occurred
 * 
 * @remarks
 * After sending this message, the Worker is in an undefined state.
 * The Supervisor should immediately terminate and recreate the Worker.
 */
export interface PanicMessage {
    readonly kind: 'PANIC'
    /** Panic reason/message */
    readonly reason: string
    /** Stack trace if available */
    readonly stack?: string
}

/**
 * Heartbeat acknowledgment for liveness check
 */
export interface HeartbeatAckMessage {
    readonly kind: 'HEARTBEAT_ACK'
    /** Echo back the timestamp */
    readonly timestamp: number
}

/**
 * Reset completed successfully
 */
export interface ResetSuccessMessage {
    readonly kind: 'RESET_SUCCESS'
    readonly requestId: string
}

/**
 * Outline extraction result
 * Sent after successful compilation with document structure data
 */
export interface OutlineResultMessage {
    readonly kind: 'OUTLINE_RESULT'
    /** Match to original compile request */
    readonly requestId: string
    /** Outline data payload */
    readonly payload: OutlineData
}

/**
 * Source Probe extraction result
 * Sent after successful compilation with embedded probe data
 */
export interface ProbeResultMessage {
    readonly kind: 'PROBE_RESULT'
    /** Match to original compile request */
    readonly requestId: string
    /** Probe data payload */
    readonly payload: ProbeData
}

/**
 * Discriminated union of all outbound message types
 */
export type WorkerToMainMessage =
    | ReadyMessage
    | CompileSuccessMessage
    | CompileErrorMessage
    | PanicMessage
    | HeartbeatAckMessage
    | ResetSuccessMessage
    | OutlineResultMessage
    | ProbeResultMessage

// ============================================================================
// Supporting Types
// ============================================================================

/**
 * Diagnostic information from the Typst compiler
 */
export interface DiagnosticInfo {
    /** Severity level */
    readonly severity: 'error' | 'warning' | 'info' | 'hint'
    /** Human-readable message */
    readonly message: string
    /** File path where the issue occurred */
    readonly path?: string
    /** Line/column range */
    readonly range?: string
    /** Package name if applicable */
    readonly package?: string
}

/** Alias for backward compatibility */
export type DiagnosticMessage = DiagnosticInfo

/**
 * Worker health metrics for monitoring
 */
export interface WorkerHealthMetrics {
    /** Memory usage in bytes */
    readonly memoryUsage: number
    /** Worker uptime in ms */
    readonly uptime: number
    /** Total compilation count */
    readonly compileCount: number
    /** Average compile time in ms */
    readonly averageCompileTime: number
    /** Last artifact size in bytes */
    readonly lastArtifactSize: number
    /** Estimated page count */
    readonly estimatedPages: number
}

/**
 * Compile result returned by the Supervisor hook
 */
export interface CompileResult {
    /** Compiled artifact data (null on error) */
    readonly artifact: Uint8Array | null
    /** Compilation timing in ms */
    readonly timing: number
    /** Whether compilation had errors */
    readonly hasError: boolean
    /** Diagnostic messages */
    readonly diagnostics: DiagnosticInfo[]
}

/**
 * Custom error class for Worker crashes
 * 
 * Can be caught by React Error Boundaries
 */
export class WorkerCrashedError extends Error {
    readonly name = 'WorkerCrashedError'
    readonly reason: string
    readonly stack?: string

    constructor(reason: string, stack?: string) {
        super(`Typst Worker crashed: ${reason}`)
        this.reason = reason
        if (stack) {
            this.stack = stack
        }
    }
}

// ============================================================================
// Type Guards
// ============================================================================

/**
 * Check if a message is a compile success
 */
export function isCompileSuccess(msg: WorkerToMainMessage): msg is CompileSuccessMessage {
    return msg.kind === 'COMPILE_SUCCESS'
}

/**
 * Check if a message is a panic
 */
export function isPanic(msg: WorkerToMainMessage): msg is PanicMessage {
    return msg.kind === 'PANIC'
}

/**
 * Check if a message is a heartbeat ack
 */
export function isHeartbeatAck(msg: WorkerToMainMessage): msg is HeartbeatAckMessage {
    return msg.kind === 'HEARTBEAT_ACK'
}

/**
 * Check if a message is an outline result
 */
export function isOutlineResult(msg: WorkerToMainMessage): msg is OutlineResultMessage {
    return msg.kind === 'OUTLINE_RESULT'
}

/**
 * Check if a message is a probe result
 */
export function isProbeResult(msg: WorkerToMainMessage): msg is ProbeResultMessage {
    return msg.kind === 'PROBE_RESULT'
}

/**
 * Type guard for GeoProbe
 */
export function isGeoProbe(probe: Probe): probe is GeoProbe {
    return probe.type === 'geo'
}

/**
 * Type guard for StructProbe
 */
export function isStructProbe(probe: Probe): probe is StructProbe {
    return probe.type === 'struct'
}

/**
 * Type guard for SemanticProbe
 */
export function isSemanticProbe(probe: Probe): probe is SemanticProbe {
    return probe.type === 'semantic'
}

// ============================================================================
// Type-Safe Message Sending
// ============================================================================

/**
 * Send a message to the worker with compile-time type validation
 * 
 * @example
 * ```typescript
 * sendToWorker(worker, {
 *   kind: 'COMPILE',
 *   source: '...',
 *   requestId: '123'
 * })
 * ```
 */
export function sendToWorker(
    worker: Worker,
    message: MainToWorkerMessage,
    transfer?: Transferable[]
): void {
    if (transfer && transfer.length > 0) {
        worker.postMessage(message satisfies MainToWorkerMessage, transfer)
    } else {
        worker.postMessage(message satisfies MainToWorkerMessage)
    }
}

/**
 * Post a response from worker to main thread with type validation
 */
export function postWorkerResponse(
    message: WorkerToMainMessage,
    transfer?: Transferable[]
): void {
    if (transfer && transfer.length > 0) {
        self.postMessage(message satisfies WorkerToMainMessage, transfer)
    } else {
        self.postMessage(message satisfies WorkerToMainMessage)
    }
}
