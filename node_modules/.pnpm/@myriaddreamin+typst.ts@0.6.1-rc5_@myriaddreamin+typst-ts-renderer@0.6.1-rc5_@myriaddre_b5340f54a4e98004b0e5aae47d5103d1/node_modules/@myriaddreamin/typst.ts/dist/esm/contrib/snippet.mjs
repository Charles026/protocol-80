import { withPackageRegistry, withAccessModel, preloadFontAssets, disableDefaultFontAssets, loadFonts, } from '../options.init.mjs';
import { loadFontSync } from '../init.mjs';
import { MemoryAccessModel } from '../fs/index.mjs';
import { FetchPackageRegistry } from '../fs/package.mjs';
import { randstr } from '../utils.mjs';
import { CompileFormatEnum } from '../compiler.mjs';
const isNode = 
// @ts-ignore
typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
/**
 * Convenient util class for compiling documents, which is a wrapper of the
 * {@link TypstCompiler} and {@link TypstRenderer}.
 *
 * Note: the interface of this class is less stable than {@link TypstCompiler}
 * and {@link TypstRenderer}.
 *
 * @example
 * Use the *global shared* compiler instance:
 *
 * ```typescript
 * import { $typst } from '@myriaddreamin/typst.ts';
 * ```
 *
 * Note: if you want to compile multiple documents, you should create a new
 * instance for each compilation work or maintain the shared state on the
 * utility instance `$typst` carefully, because the compilation process will
 * change the state of that.
 *
 * @example
 * Create an instance of utility:
 *
 * ```typescript
 * const $typst = new TypstSnippet({
 *   // optional renderer instance
 *   renderer: enableRendering ?? (() => {
 *     return createGlobalRenderer(createTypstRenderer,
 *       undefined, initOptions);
 *   }),
 *   compiler() => {
 *     return createGlobalCompiler(createTypstCompiler,
 *       initOptions);
 *   }
 * });
 * ```
 */
export class TypstSnippet {
    /** @internal */
    mainFilePath;
    /** @internal */
    cc;
    /** @internal */
    fr;
    /** @internal */
    ex;
    /**
     * Create a new instance of {@link TypstSnippet}.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     *
     * @example
     *
     * Passes a global shared compiler instance that get initialized lazily:
     * ```typescript
     * const $typst = new TypstSnippet(() => {
     *  return createGlobalCompiler(createTypstCompiler, initOptions);
     * });
     *
     */
    constructor(options) {
        this.cc = options?.compiler || TypstSnippet.buildLocalCompiler;
        this.fr = options?.fontResolver || TypstSnippet.buildLocalFontResolver;
        this.ex = options?.renderer || TypstSnippet.buildLocalRenderer;
        this.mainFilePath = '/main.typ';
        this.providers = [];
    }
    /**
     * Set lazy initialized compiler instance for the utility instance.
     * @param cc the compiler instance, see {@link PromiseJust} and {@link TypstCompiler}.
     */
    setCompiler(cc) {
        this.cc = cc;
    }
    async getFontResolver() {
        return (typeof this.fr === 'function' ? (this.fr = await this.fr()) : this.fr);
    }
    /**
     * Get an initialized compiler instance from the utility instance.
     */
    async getCompiler() {
        return (typeof this.cc === 'function' ? (this.cc = await this.cc()) : this.cc);
    }
    async getCompilerReset() {
        const compiler = await this.getCompiler();
        await compiler.reset();
        return compiler;
    }
    /**
     * Set lazy initialized renderer instance for the utility instance.
     * @param ex the renderer instance, see {@link PromiseJust} and {@link TypstRenderer}.
     */
    setRenderer(ex) {
        this.ex = ex;
    }
    /**
     * Get an initialized renderer instance from the utility instance.
     */
    async getRenderer() {
        return typeof this.ex === 'function' ? (this.ex = await this.ex()) : this.ex;
    }
    providers;
    /**
     * add providers for bullding the compiler or renderer component.
     */
    use(...providers) {
        if (!this.providers) {
            throw new Error('already prepare uses for instances');
        }
        this.providers.push(...providers);
    }
    /**
     * todo: add docs
     */
    static preloadFontFromUrl(fontUrl) {
        return TypstSnippet.preloadFonts([fontUrl]);
    }
    /**
     * todo: add docs
     */
    static preloadFontData(fontData) {
        return TypstSnippet.preloadFonts([fontData]);
    }
    /**
     * todo: add docs
     */
    static preloadFonts(userFonts) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [loadFonts(userFonts)],
        };
    }
    /**
     * don't load any default font assets.
     * todo: add docs
     */
    static disableDefaultFontAssets() {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [disableDefaultFontAssets()],
        };
    }
    /**
     * todo: add docs
     */
    static preloadFontAssets(options) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [preloadFontAssets(options)],
        };
    }
    /**
     * Set accessl model for the compiler instance
     * @example
     *
     * use memory access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m));
     * ```
     */
    static withAccessModel(accessModel) {
        return {
            key: 'access-model',
            forRoles: ['compiler'],
            provides: [withAccessModel(accessModel)],
        };
    }
    /**
     * Set package registry for the compiler instance
     * @example
     *
     * use a customized package registry
     *
     * ```typescript
     * const n = new NodeFetchPackageRegistry();
     * $typst.use(TypstSnippet.withPackageRegistry(n));
     * ```
     */
    static withPackageRegistry(registry) {
        return {
            key: 'package-registry',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(registry)],
        };
    }
    /**
     * Retrieve an access model to store the data of fetched files.
     * Provide a PackageRegistry instance for the compiler instance.
     *
     * @example
     *
     * use default (memory) access model
     *
     * ```typescript
     * $typst.use(await TypstSnippet.fetchPackageRegistry());
     * ```
     *
     * @example
     *
     * use external access model
     *
     * ```typescript
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageRegistry(m));
     * ```
     */
    static fetchPackageRegistry(accessModel) {
        const m = accessModel || new MemoryAccessModel();
        const provides = [
            ...(accessModel ? [] : [withAccessModel(m)]),
            withPackageRegistry(new FetchPackageRegistry(m)),
        ];
        return {
            key: 'package-registry$fetch',
            forRoles: ['compiler'],
            provides,
        };
    }
    /**
     * Retrieve a fetcher for fetching package data.
     * Provide a PackageRegistry instance for the compiler instance.
     * @example
     *
     * use a customized fetcher
     *
     * ```typescript
     * import request from 'sync-request-curl';
     * const m = new MemoryAccessModel();
     * $typst.use(TypstSnippet.withAccessModel(m), await TypstSnippet.fetchPackageBy(m, (_, httpUrl) => {
     *   const response = request('GET', this.resolvePath(path), {
     *     insecure: true,
     *   });
     *
     *   if (response.statusCode === 200) {
     *     return response.getBody(undefined);
     *   }
     *   return undefined;
     * }));
     * ```
     */
    static fetchPackageBy(accessModel, fetcher) {
        class HttpPackageRegistry extends FetchPackageRegistry {
            pullPackageData(path) {
                return fetcher(path, this.resolvePath(path));
            }
        }
        return {
            key: 'package-registry$lambda',
            forRoles: ['compiler'],
            provides: [withPackageRegistry(new HttpPackageRegistry(accessModel))],
        };
    }
    /** @internal */
    ccOptions;
    /**
     * Set compiler init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setCompilerInitOptions(options) {
        this.requireIsUninitialized('compiler', this.cc);
        this.ccOptions = options;
    }
    /** @internal */
    exOptions;
    /**
     * Set renderer init options for initializing global instance {@link $typst}.
     * See {@link InitOptions}.
     */
    setRendererInitOptions(options) {
        this.requireIsUninitialized('renderer', this.ex);
        this.exOptions = options;
    }
    /**
     * Set shared main file path.
     */
    setMainFilePath(path) {
        this.mainFilePath = path;
    }
    /**
     * Get shared main file path.
     */
    getMainFilePath() {
        return this.mainFilePath;
    }
    removeTmp(opts) {
        if (opts.mainFilePath.startsWith('/tmp/')) {
            return this.unmapShadow(opts.mainFilePath);
        }
        return Promise.resolve();
    }
    /**
     * Adds a font to the compiler.
     *
     * @example
     *
     * ```typescript
     * const fonts = await fetch('fontInfo.json').then(res => res.json());
     * $typst.addFonts(fonts.map(font => $typst.loadFont(font.url)));
     * ```
     *
     * @param fontInfos the font infos to add.
     */
    async setFonts(fontInfos) {
        const fb = await this.getFontResolver();
        for (const font of fontInfos) {
            await fb.addLazyFont(font, 'blob' in font ? font.blob : loadFontSync(font), font);
        }
        const compiler = await this.getCompiler();
        await fb.build(async (fonts) => compiler.setFonts(fonts));
    }
    /**
     * Add a source file to the compiler.
     * See {@link TypstCompiler#addSource}.
     */
    async addSource(path, content) {
        (await this.getCompiler()).addSource(path, content);
    }
    /**
     * Reset the shadow files.
     * Note: this function is independent to the {@link reset} function.
     * See {@link TypstCompiler#resetShadow}.
     */
    async resetShadow() {
        (await this.getCompiler()).resetShadow();
    }
    /**
     * Add a shadow file to the compiler.
     * See {@link TypstCompiler#mapShadow}.
     */
    async mapShadow(path, content) {
        (await this.getCompiler()).mapShadow(path, content);
    }
    /**
     * Remove a shadow file from the compiler.
     * See {@link TypstCompiler#unmapShadow}.
     */
    async unmapShadow(path) {
        (await this.getCompiler()).unmapShadow(path);
    }
    /**
     * Compile the document to vector (IR) format.
     * See {@link SweetCompileOptions}.
     */
    async vector(o) {
        const opts = await this.getCompileOptions(o);
        const compiler = await this.getCompilerReset();
        return compiler
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to PDF format.
     * See {@link SweetCompileOptions}.
     */
    async pdf(o) {
        const opts = await this.getCompileOptions(o);
        opts.format = CompileFormatEnum.pdf;
        const compiler = await this.getCompilerReset();
        return compiler
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Compile the document to SVG format.
     * See {@link SweetRenderOptions} and {@link RenderSvgOptions}.
     */
    async svg(o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderSvg({
            ...o,
            renderSession,
        }));
    }
    /**
     * Compile the document to canvas operations.
     * See {@link SweetRenderOptions} and {@link RenderToCanvasOptions}.
     */
    async canvas(container, o) {
        return this.transientRender(o, (renderer, renderSession) => renderer.renderToCanvas({
            container,
            ...o,
            renderSession,
        }));
    }
    /**
     * Get semantic tokens for the document.
     */
    async query(o) {
        const opts = await this.getCompileOptions(o);
        const compiler = await this.getCompilerReset();
        return compiler
            .query({
            ...o,
            ...opts,
        })
            .finally(() => this.removeTmp(opts));
    }
    /**
     * Get token legend for semantic tokens.
     */
    async getSemanticTokenLegend() {
        const compiler = await this.getCompilerReset();
        return compiler.getSemanticTokenLegend();
    }
    /**
     * Get semantic tokens for the document.
     * See {@link SweetCompileOptions}.
     * See {@link TypstCompiler#getSemanticTokens}.
     */
    async getSemanticTokens(o) {
        const opts = await this.getCompileOptions(o);
        const compiler = await this.getCompilerReset();
        return compiler
            .getSemanticTokens({
            mainFilePath: opts.mainFilePath,
            resultId: o.resultId,
        })
            .finally(() => this.removeTmp(opts));
    }
    async getCompileOptions(opts) {
        if (opts === undefined) {
            return { mainFilePath: this.mainFilePath, diagnostics: 'none' };
        }
        else if (typeof opts === 'string') {
            throw new Error(`please specify opts as {mainContent: '...'} or {mainFilePath: '...'}`);
        }
        else if ('mainFilePath' in opts) {
            return { ...opts, diagnostics: 'none' };
        }
        else {
            const destFile = `/tmp/${randstr()}.typ`;
            await this.addSource(destFile, opts.mainContent);
            return { mainFilePath: destFile, inputs: opts.inputs, diagnostics: 'none' };
        }
    }
    async getVector(o) {
        if (o && 'vectorData' in o) {
            return o.vectorData;
        }
        const opts = await this.getCompileOptions(o);
        return (await this.getCompiler())
            .compile(opts)
            .then(res => res.result)
            .finally(() => this.removeTmp(opts));
    }
    async transientRender(opts, f) {
        const rr = await this.getRenderer();
        if (!rr) {
            throw new Error('does not provide renderer instance');
        }
        const data = await this.getVector(opts);
        return await rr.runWithSession(async (session) => {
            rr.manipulateData({
                renderSession: session,
                action: 'reset',
                data,
            });
            return f(rr, session);
        });
    }
    prepareUseOnce = undefined;
    async prepareUse() {
        if (this.prepareUseOnce) {
            return this.prepareUseOnce;
        }
        return (this.prepareUseOnce = this.doPrepareUse());
    }
    async doPrepareUse() {
        if (!this.providers) {
            return;
        }
        const providers = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        this.providers = [];
        if ($typst == this &&
            !providers.some(p => p.key.includes('package-registry') || p.key.includes('access-model'))) {
            // Note: the default fetch backend always adds a withAccessModel(mem)
            if (isNode) {
                const escapeImport = new Function('m', 'return import(m)');
                try {
                    const m = new MemoryAccessModel();
                    const { default: request } = await escapeImport('sync-request');
                    $typst.use(TypstSnippet.withAccessModel(m), TypstSnippet.fetchPackageBy(m, (_, path) => {
                        const response = request('GET', path);
                        if (response.statusCode === 200) {
                            return response.getBody(undefined);
                        }
                        return undefined;
                    }));
                }
                catch (e) { }
            }
            else {
                $typst.use(TypstSnippet.fetchPackageRegistry());
            }
        }
        const providers2 = await Promise.all(this.providers.map(p => (typeof p === 'function' ? p() : p)));
        const ccOptions = (this.ccOptions ||= {});
        const ccBeforeBuild = (ccOptions.beforeBuild ||= []);
        const exOptions = (this.exOptions ||= {});
        const exBeforeBuild = (exOptions.beforeBuild ||= []);
        for (const provider of [...providers, ...providers2]) {
            if (provider.forRoles.includes('compiler')) {
                this.requireIsUninitialized('compiler', this.cc);
                ccBeforeBuild.push(...provider.provides);
            }
            if (provider.forRoles.includes('renderer')) {
                this.requireIsUninitialized('renderer', this.ex);
                exBeforeBuild.push(...provider.provides);
            }
        }
        this.providers = undefined;
    }
    requireIsUninitialized(role, c, e) {
        if (c && typeof c !== 'function') {
            throw new Error(`${role} has been initialized: ${c}`);
        }
    }
    /** @internal */
    static async buildLocalCompiler() {
        const { createTypstCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/compiler'));
        await this.prepareUse();
        const compiler = createTypstCompiler();
        await compiler.init(this.ccOptions);
        return compiler;
    }
    /** @internal */
    static async buildLocalFontResolver() {
        const { createTypstFontBuilder } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/compiler'));
        await this.prepareUse();
        const fonts = createTypstFontBuilder();
        await fonts.init(this.ccOptions);
        return fonts;
    }
    /** @internal */
    static async buildGlobalCompiler() {
        // lazy import compile module
        const { createGlobalCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/contrib/global-compiler'));
        const { createTypstCompiler } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/compiler'));
        await this.prepareUse();
        return createGlobalCompiler(createTypstCompiler, this.ccOptions);
    }
    /** @internal */
    static async buildLocalRenderer() {
        const { createTypstRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/renderer'));
        await this.prepareUse();
        const renderer = createTypstRenderer();
        await renderer.init(this.exOptions);
        return renderer;
    }
    /** @internal */
    static async buildGlobalRenderer() {
        // lazy import renderer module
        const { createGlobalRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/contrib/global-renderer'));
        const { createTypstRenderer } = (await import(
        // @ts-ignore
        '@myriaddreamin/typst.ts/renderer'));
        await this.prepareUse();
        return createGlobalRenderer(createTypstRenderer, this.exOptions);
    }
}
/**
 * The lazy initialized global shared instance of {@link TypstSnippet}. See
 * {@link TypstSnippet} for more details.
 */
export const $typst = new TypstSnippet({
    compiler: TypstSnippet.buildGlobalCompiler,
    renderer: TypstSnippet.buildGlobalRenderer,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic25pcHBldC5tanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJpYi9zbmlwcGV0Lm10cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLGVBQWUsRUFHZixpQkFBaUIsRUFDakIsd0JBQXdCLEVBQ3hCLFNBQVMsR0FFVixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFHM0MsT0FBTyxFQUFFLGlCQUFpQixFQUE0QixNQUFNLGlCQUFpQixDQUFDO0FBQzlFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBT3pELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUE4RXBELE1BQU0sTUFBTTtBQUNWLGFBQWE7QUFDYixPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLFFBQVEsSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO0FBRTlGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ3ZCLGdCQUFnQjtJQUNSLFlBQVksQ0FBUztJQUM3QixnQkFBZ0I7SUFDUixFQUFFLENBQThCO0lBQ3hDLGdCQUFnQjtJQUNSLEVBQUUsQ0FBaUM7SUFDM0MsZ0JBQWdCO0lBQ1IsRUFBRSxDQUE4QjtJQUV4Qzs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsWUFBWSxPQUlYO1FBQ0MsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPLEVBQUUsUUFBUSxJQUFJLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQztRQUMvRCxJQUFJLENBQUMsRUFBRSxHQUFHLE9BQU8sRUFBRSxZQUFZLElBQUksWUFBWSxDQUFDLHNC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QyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN4QixNQUFNLFFBQVEsR0FBRyxtQkFBbUIsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDcEMsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVELGdCQUFnQjtJQUNoQixNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQjtRQUM5Qiw4QkFBOEI7UUFDOUIsTUFBTSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsQ0FBQyxNQUFNLE1BQU07UUFDNUMsYUFBYTtRQUNiLGlEQUFpRCxDQUNsRCxDQUFrRCxDQUFDO1FBQ3BELE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxHQUFHLENBQUMsTUFBTSxNQUFNO1FBQzNDLGFBQWE7UUFDYixrQ0FBa0MsQ0FDbkMsQ0FBNEMsQ0FBQztRQUU5QyxNQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN4QixPQUFPLG9CQUFvQixDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUM7SUFDckMsUUFBUSxFQUFFLFlBQVksQ0FBQyxtQkFBbUI7SUFDMUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxtQkFBbUI7Q0FDM0MsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBDb21waWxlT3B0aW9ucywgVHlwc3RDb21waWxlciwgVHlwc3RGb250QnVpbGRlciB9IGZyb20gJy4uL2NvbXBpbGVyLm1qcyc7XHJcbmltcG9ydCB7XHJcbiAgd2l0aFBhY2thZ2VSZWdpc3RyeSxcclxuICB3aXRoQWNjZXNzTW9kZWwsXHJcbiAgdHlwZSBCZWZvcmVCdWlsZEZuLFxyXG4gIHR5cGUgSW5pdE9wdGlvbnMsXHJcbiAgcHJlbG9hZEZvbnRBc3NldHMsXHJcbiAgZGlzYWJsZURlZmF1bHRGb250QXNzZXRzLFxyXG4gIGxvYWRGb250cyxcclxuICBMb2FkUmVtb3RlQXNzZXRzT3B0aW9ucyxcclxufSBmcm9tICcuLi9vcHRpb25zLmluaXQubWpzJztcclxuaW1wb3J0IHsgbG9hZEZvbnRTeW5jIH0gZnJvbSAnLi4vaW5pdC5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFR5cHN0UmVuZGVyZXIsIFJlbmRlclNlc3Npb24gfSBmcm9tICcuLi9yZW5kZXJlci5tanMnO1xyXG5pbXBvcnQgdHlwZSB7IFJlbmRlclRvQ2FudmFzT3B0aW9ucywgUmVuZGVyU3ZnT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMucmVuZGVyLm1qcyc7XHJcbmltcG9ydCB7IE1lbW9yeUFjY2Vzc01vZGVsLCB0eXBlIFdyaXRhYmxlQWNjZXNzTW9kZWwgfSBmcm9tICcuLi9mcy9pbmRleC5tanMnO1xyXG5pbXBvcnQgeyBGZXRjaFBhY2thZ2VSZWdpc3RyeSB9IGZyb20gJy4uL2ZzL3BhY2thZ2UubWpzJztcclxuaW1wb3J0IHtcclxuICBQYWNrYWdlUmVnaXN0cnksXHJcbiAgUGFja2FnZVNwZWMsXHJcbiAgU2VtYW50aWNUb2tlbnMsXHJcbiAgU2VtYW50aWNUb2tlbnNMZWdlbmQsXHJcbn0gZnJvbSAnLi4vaW50ZXJuYWwudHlwZXMubWpzJztcclxuaW1wb3J0IHsgcmFuZHN0ciB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XHJcbmltcG9ydCB7IENvbXBpbGVGb3JtYXRFbnVtIH0gZnJvbSAnLi4vY29tcGlsZXIubWpzJztcclxuXHJcbi8qKlxyXG4gKiBTb21lIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2Ugb2YgdmFsdWUgb3IganVzdCB0aGF0IHZhbHVlLlxyXG4gKi9cclxudHlwZSBQcm9taXNlSnVzdDxUPiA9ICgoKSA9PiBQcm9taXNlPFQ+KSB8IFQ7XHJcblxyXG5pbnRlcmZhY2UgQ29tcGlsZU9wdGlvbnNDb21tb24ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSByb290IG9mIHRoZSBtYWluIGZpbGUuXHJcbiAgICovXHJcbiAgcm9vdD86IHN0cmluZztcclxuICAvKipcclxuICAgKiBBZGRzIGEgc3RyaW5nIGtleS12YWx1ZSBwYWlyIHZpc2libGUgdGhyb3VnaCBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IHBhc3MgYHt9YCB0byBjbGVhciBgc3lzLmlucHV0c2BcclxuICAgKlxyXG4gICAqIE5vdGU6IFdoZW4gcGFzc2luZyBgdW5kZWZpbmVkYCwgY29tcGlsZXIgd2lsbCB1c2UgbGFzdCBzZXQgYHN5cy5pbnB1dHNgLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBtZWFucyB5b3Ugc2hvdWxkIGFsd2F5cyBzcGVjaWZ5IGlucHV0cyB3aGVuIHVzaW5nIGNvbXBpbGVyIGZvciBjb25jdXJyZW50IHRhc2tzLlxyXG4gICAqL1xyXG4gIGlucHV0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgc3dlZXQgb3B0aW9ucyBmb3IgY29tcGlsaW5nIGFuZCByZW5kZXJpbmcgdGhlIGRvY3VtZW50LlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgU3dlZXRDb21waWxlT3B0aW9ucyA9IChcclxuICB8IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhdGggb2YgdGhlIG1haW4gZmlsZS5cclxuICAgICAqL1xyXG4gICAgbWFpbkZpbGVQYXRoOiBzdHJpbmc7XHJcbiAgfVxyXG4gIHwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc291cmNlIGNvbnRlbnQgb2YgdGhlIG1haW4gZmlsZS5cclxuICAgICAqL1xyXG4gICAgbWFpbkNvbnRlbnQ6IHN0cmluZztcclxuICB9XHJcbikgJlxyXG4gIENvbXBpbGVPcHRpb25zQ29tbW9uO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzd2VldCBvcHRpb25zIGZvciBjb21waWxpbmcgYW5kIHJlbmRlcmluZyB0aGUgZG9jdW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTd2VldFJlbmRlck9wdGlvbnMgPVxyXG4gIHwgU3dlZXRDb21waWxlT3B0aW9uc1xyXG4gIHwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXJ0aWZhY3QgZGF0YSBpbiB2ZWN0b3IgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICB2ZWN0b3JEYXRhOiBVaW50OEFycmF5O1xyXG4gIH07XHJcblxyXG5leHBvcnQgdHlwZSBTd2VldExhenlGb250ID0ge1xyXG4gIGluZm86IGFueTtcclxufSAmIChcclxuICAgIHwge1xyXG4gICAgICBibG9iOiAoaW5kZXg6IG51bWJlcikgPT4gVWludDhBcnJheTtcclxuICAgIH1cclxuICAgIHwge1xyXG4gICAgICB1cmw6IHN0cmluZztcclxuICAgIH1cclxuICApO1xyXG5cclxudHlwZSBSb2xlID0gJ2NvbXBpbGVyJyB8ICdyZW5kZXJlcic7XHJcblxyXG4vKipcclxuICogVGhlIHN3ZWV0IHNuaXBwZXQgcHJvdmlkZXIgZm9yIGJ1bGxkaW5nIHRoZSBjb21waWxlciBvciByZW5kZXJlciBjb21wb25lbnQuXHJcbiAqIFNlZSB7QGxpbmsgVHlwc3RTbmlwcGV0I3VzZX0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIGZvclJvbGVzOiBSb2xlW107XHJcbiAgcHJvdmlkZXM6IEJlZm9yZUJ1aWxkRm5bXTtcclxufVxyXG5cclxuY29uc3QgaXNOb2RlID1cclxuICAvLyBAdHMtaWdub3JlXHJcbiAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZW5pZW50IHV0aWwgY2xhc3MgZm9yIGNvbXBpbGluZyBkb2N1bWVudHMsIHdoaWNoIGlzIGEgd3JhcHBlciBvZiB0aGVcclxuICoge0BsaW5rIFR5cHN0Q29tcGlsZXJ9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAqXHJcbiAqIE5vdGU6IHRoZSBpbnRlcmZhY2Ugb2YgdGhpcyBjbGFzcyBpcyBsZXNzIHN0YWJsZSB0aGFuIHtAbGluayBUeXBzdENvbXBpbGVyfVxyXG4gKiBhbmQge0BsaW5rIFR5cHN0UmVuZGVyZXJ9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBVc2UgdGhlICpnbG9iYWwgc2hhcmVkKiBjb21waWxlciBpbnN0YW5jZTpcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQgeyAkdHlwc3QgfSBmcm9tICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cyc7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBOb3RlOiBpZiB5b3Ugd2FudCB0byBjb21waWxlIG11bHRpcGxlIGRvY3VtZW50cywgeW91IHNob3VsZCBjcmVhdGUgYSBuZXdcclxuICogaW5zdGFuY2UgZm9yIGVhY2ggY29tcGlsYXRpb24gd29yayBvciBtYWludGFpbiB0aGUgc2hhcmVkIHN0YXRlIG9uIHRoZVxyXG4gKiB1dGlsaXR5IGluc3RhbmNlIGAkdHlwc3RgIGNhcmVmdWxseSwgYmVjYXVzZSB0aGUgY29tcGlsYXRpb24gcHJvY2VzcyB3aWxsXHJcbiAqIGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhhdC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHV0aWxpdHk6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgJHR5cHN0ID0gbmV3IFR5cHN0U25pcHBldCh7XHJcbiAqICAgLy8gb3B0aW9uYWwgcmVuZGVyZXIgaW5zdGFuY2VcclxuICogICByZW5kZXJlcjogZW5hYmxlUmVuZGVyaW5nID8/ICgoKSA9PiB7XHJcbiAqICAgICByZXR1cm4gY3JlYXRlR2xvYmFsUmVuZGVyZXIoY3JlYXRlVHlwc3RSZW5kZXJlcixcclxuICogICAgICAgdW5kZWZpbmVkLCBpbml0T3B0aW9ucyk7XHJcbiAqICAgfSksXHJcbiAqICAgY29tcGlsZXIoKSA9PiB7XHJcbiAqICAgICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlcixcclxuICogICAgICAgaW5pdE9wdGlvbnMpO1xyXG4gKiAgIH1cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFR5cHN0U25pcHBldCB7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHByaXZhdGUgbWFpbkZpbGVQYXRoOiBzdHJpbmc7XHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHByaXZhdGUgY2M/OiBQcm9taXNlSnVzdDxUeXBzdENvbXBpbGVyPjtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgcHJpdmF0ZSBmcj86IFByb21pc2VKdXN0PFR5cHN0Rm9udEJ1aWxkZXI+O1xyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBwcml2YXRlIGV4PzogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj47XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHlwc3RTbmlwcGV0fS5cclxuICAgKiBAcGFyYW0gY2MgdGhlIGNvbXBpbGVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0Q29tcGlsZXJ9LlxyXG4gICAqIEBwYXJhbSBleCB0aGUgcmVuZGVyZXIgaW5zdGFuY2UsIHNlZSB7QGxpbmsgUHJvbWlzZUp1c3R9IGFuZCB7QGxpbmsgVHlwc3RSZW5kZXJlcn0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogUGFzc2VzIGEgZ2xvYmFsIHNoYXJlZCBjb21waWxlciBpbnN0YW5jZSB0aGF0IGdldCBpbml0aWFsaXplZCBsYXppbHk6XHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0ICR0eXBzdCA9IG5ldyBUeXBzdFNuaXBwZXQoKCkgPT4ge1xyXG4gICAqICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlciwgaW5pdE9wdGlvbnMpO1xyXG4gICAqIH0pO1xyXG4gICAqXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IHtcclxuICAgIGNvbXBpbGVyPzogUHJvbWlzZUp1c3Q8VHlwc3RDb21waWxlcj47XHJcbiAgICBmb250UmVzb2x2ZXI/OiBQcm9taXNlSnVzdDxUeXBzdEZvbnRCdWlsZGVyPjtcclxuICAgIHJlbmRlcmVyPzogUHJvbWlzZUp1c3Q8VHlwc3RSZW5kZXJlcj47XHJcbiAgfSkge1xyXG4gICAgdGhpcy5jYyA9IG9wdGlvbnM/LmNvbXBpbGVyIHx8IFR5cHN0U25pcHBldC5idWlsZExvY2FsQ29tcGlsZXI7XHJcbiAgICB0aGlzLmZyID0gb3B0aW9ucz8uZm9udFJlc29sdmVyIHx8IFR5cHN0U25pcHBldC5idWlsZExvY2FsRm9udFJlc29sdmVyO1xyXG4gICAgdGhpcy5leCA9IG9wdGlvbnM/LnJlbmRlcmVyIHx8IFR5cHN0U25pcHBldC5idWlsZExvY2FsUmVuZGVyZXI7XHJcbiAgICB0aGlzLm1haW5GaWxlUGF0aCA9ICcvbWFpbi50eXAnO1xyXG4gICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBsYXp5IGluaXRpYWxpemVkIGNvbXBpbGVyIGluc3RhbmNlIGZvciB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gY2MgdGhlIGNvbXBpbGVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0Q29tcGlsZXJ9LlxyXG4gICAqL1xyXG4gIHNldENvbXBpbGVyKGNjOiBQcm9taXNlSnVzdDxUeXBzdENvbXBpbGVyPikge1xyXG4gICAgdGhpcy5jYyA9IGNjO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Rm9udFJlc29sdmVyKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5mciA9PT0gJ2Z1bmN0aW9uJyA/ICh0aGlzLmZyID0gYXdhaXQgdGhpcy5mcigpKSA6IHRoaXMuZnIpITtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBpbml0aWFsaXplZCBjb21waWxlciBpbnN0YW5jZSBmcm9tIHRoZSB1dGlsaXR5IGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGFzeW5jIGdldENvbXBpbGVyKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdGhpcy5jYyA9PT0gJ2Z1bmN0aW9uJyA/ICh0aGlzLmNjID0gYXdhaXQgdGhpcy5jYygpKSA6IHRoaXMuY2MpITtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q29tcGlsZXJSZXNldCgpIHtcclxuICAgIGNvbnN0IGNvbXBpbGVyID0gYXdhaXQgdGhpcy5nZXRDb21waWxlcigpO1xyXG4gICAgYXdhaXQgY29tcGlsZXIucmVzZXQoKTtcclxuICAgIHJldHVybiBjb21waWxlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBsYXp5IGluaXRpYWxpemVkIHJlbmRlcmVyIGluc3RhbmNlIGZvciB0aGUgdXRpbGl0eSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gZXggdGhlIHJlbmRlcmVyIGluc3RhbmNlLCBzZWUge0BsaW5rIFByb21pc2VKdXN0fSBhbmQge0BsaW5rIFR5cHN0UmVuZGVyZXJ9LlxyXG4gICAqL1xyXG4gIHNldFJlbmRlcmVyKGV4OiBQcm9taXNlSnVzdDxUeXBzdFJlbmRlcmVyPikge1xyXG4gICAgdGhpcy5leCA9IGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGluaXRpYWxpemVkIHJlbmRlcmVyIGluc3RhbmNlIGZyb20gdGhlIHV0aWxpdHkgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0UmVuZGVyZXIoKTogUHJvbWlzZTxUeXBzdFJlbmRlcmVyPiB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZXggPT09ICdmdW5jdGlvbicgPyAodGhpcy5leCA9IGF3YWl0IHRoaXMuZXgoKSkgOiB0aGlzLmV4ITtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcHJvdmlkZXJzPzogUHJvbWlzZUp1c3Q8VHlwc3RTbmlwcGV0UHJvdmlkZXI+W107XHJcbiAgLyoqXHJcbiAgICogYWRkIHByb3ZpZGVycyBmb3IgYnVsbGRpbmcgdGhlIGNvbXBpbGVyIG9yIHJlbmRlcmVyIGNvbXBvbmVudC5cclxuICAgKi9cclxuICB1c2UoLi4ucHJvdmlkZXJzOiBQcm9taXNlSnVzdDxUeXBzdFNuaXBwZXRQcm92aWRlcj5bXSkge1xyXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVycykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgcHJlcGFyZSB1c2VzIGZvciBpbnN0YW5jZXMnKTtcclxuICAgIH1cclxuICAgIHRoaXMucHJvdmlkZXJzLnB1c2goLi4ucHJvdmlkZXJzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHRvZG86IGFkZCBkb2NzXHJcbiAgICovXHJcbiAgc3RhdGljIHByZWxvYWRGb250RnJvbVVybChmb250VXJsOiBzdHJpbmcpOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICByZXR1cm4gVHlwc3RTbmlwcGV0LnByZWxvYWRGb250cyhbZm9udFVybF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogdG9kbzogYWRkIGRvY3NcclxuICAgKi9cclxuICBzdGF0aWMgcHJlbG9hZEZvbnREYXRhKGZvbnREYXRhOiBVaW50OEFycmF5KTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIFR5cHN0U25pcHBldC5wcmVsb2FkRm9udHMoW2ZvbnREYXRhXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiB0b2RvOiBhZGQgZG9jc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBwcmVsb2FkRm9udHModXNlckZvbnRzOiAoc3RyaW5nIHwgVWludDhBcnJheSlbXSk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ2FjY2Vzcy1tb2RlbCcsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbbG9hZEZvbnRzKHVzZXJGb250cyldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGRvbid0IGxvYWQgYW55IGRlZmF1bHQgZm9udCBhc3NldHMuXHJcbiAgICogdG9kbzogYWRkIGRvY3NcclxuICAgKi9cclxuICBzdGF0aWMgZGlzYWJsZURlZmF1bHRGb250QXNzZXRzKCk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ2FjY2Vzcy1tb2RlbCcsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbZGlzYWJsZURlZmF1bHRGb250QXNzZXRzKCldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHRvZG86IGFkZCBkb2NzXHJcbiAgICovXHJcbiAgc3RhdGljIHByZWxvYWRGb250QXNzZXRzKG9wdGlvbnM/OiBMb2FkUmVtb3RlQXNzZXRzT3B0aW9ucyk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ2FjY2Vzcy1tb2RlbCcsXHJcbiAgICAgIGZvclJvbGVzOiBbJ2NvbXBpbGVyJ10sXHJcbiAgICAgIHByb3ZpZGVzOiBbcHJlbG9hZEZvbnRBc3NldHMob3B0aW9ucyldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhY2Nlc3NsIG1vZGVsIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2VcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIG1lbW9yeSBhY2Nlc3MgbW9kZWxcclxuICAgKlxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgd2l0aEFjY2Vzc01vZGVsKGFjY2Vzc01vZGVsOiBXcml0YWJsZUFjY2Vzc01vZGVsKTogVHlwc3RTbmlwcGV0UHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAnYWNjZXNzLW1vZGVsJyxcclxuICAgICAgZm9yUm9sZXM6IFsnY29tcGlsZXInXSxcclxuICAgICAgcHJvdmlkZXM6IFt3aXRoQWNjZXNzTW9kZWwoYWNjZXNzTW9kZWwpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgcGFja2FnZSByZWdpc3RyeSBmb3IgdGhlIGNvbXBpbGVyIGluc3RhbmNlXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBhIGN1c3RvbWl6ZWQgcGFja2FnZSByZWdpc3RyeVxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IG4gPSBuZXcgTm9kZUZldGNoUGFja2FnZVJlZ2lzdHJ5KCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aFBhY2thZ2VSZWdpc3RyeShuKSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIHdpdGhQYWNrYWdlUmVnaXN0cnkocmVnaXN0cnk6IFBhY2thZ2VSZWdpc3RyeSk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ3BhY2thZ2UtcmVnaXN0cnknLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3dpdGhQYWNrYWdlUmVnaXN0cnkocmVnaXN0cnkpXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBhbiBhY2Nlc3MgbW9kZWwgdG8gc3RvcmUgdGhlIGRhdGEgb2YgZmV0Y2hlZCBmaWxlcy5cclxuICAgKiBQcm92aWRlIGEgUGFja2FnZVJlZ2lzdHJ5IGluc3RhbmNlIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGRlZmF1bHQgKG1lbW9yeSkgYWNjZXNzIG1vZGVsXHJcbiAgICpcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogJHR5cHN0LnVzZShhd2FpdCBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlUmVnaXN0cnkoKSk7XHJcbiAgICogYGBgXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogdXNlIGV4dGVybmFsIGFjY2VzcyBtb2RlbFxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IG0gPSBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgKiAkdHlwc3QudXNlKFR5cHN0U25pcHBldC53aXRoQWNjZXNzTW9kZWwobSksIGF3YWl0IFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VSZWdpc3RyeShtKSk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgc3RhdGljIGZldGNoUGFja2FnZVJlZ2lzdHJ5KGFjY2Vzc01vZGVsPzogV3JpdGFibGVBY2Nlc3NNb2RlbCk6IFR5cHN0U25pcHBldFByb3ZpZGVyIHtcclxuICAgIGNvbnN0IG0gPSBhY2Nlc3NNb2RlbCB8fCBuZXcgTWVtb3J5QWNjZXNzTW9kZWwoKTtcclxuICAgIGNvbnN0IHByb3ZpZGVzID0gW1xyXG4gICAgICAuLi4oYWNjZXNzTW9kZWwgPyBbXSA6IFt3aXRoQWNjZXNzTW9kZWwobSldKSxcclxuICAgICAgd2l0aFBhY2thZ2VSZWdpc3RyeShuZXcgRmV0Y2hQYWNrYWdlUmVnaXN0cnkobSkpLFxyXG4gICAgXTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleTogJ3BhY2thZ2UtcmVnaXN0cnkkZmV0Y2gnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlcyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBhIGZldGNoZXIgZm9yIGZldGNoaW5nIHBhY2thZ2UgZGF0YS5cclxuICAgKiBQcm92aWRlIGEgUGFja2FnZVJlZ2lzdHJ5IGluc3RhbmNlIGZvciB0aGUgY29tcGlsZXIgaW5zdGFuY2UuXHJcbiAgICogQGV4YW1wbGVcclxuICAgKlxyXG4gICAqIHVzZSBhIGN1c3RvbWl6ZWQgZmV0Y2hlclxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGltcG9ydCByZXF1ZXN0IGZyb20gJ3N5bmMtcmVxdWVzdC1jdXJsJztcclxuICAgKiBjb25zdCBtID0gbmV3IE1lbW9yeUFjY2Vzc01vZGVsKCk7XHJcbiAgICogJHR5cHN0LnVzZShUeXBzdFNuaXBwZXQud2l0aEFjY2Vzc01vZGVsKG0pLCBhd2FpdCBUeXBzdFNuaXBwZXQuZmV0Y2hQYWNrYWdlQnkobSwgKF8sIGh0dHBVcmwpID0+IHtcclxuICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdCgnR0VUJywgdGhpcy5yZXNvbHZlUGF0aChwYXRoKSwge1xyXG4gICAqICAgICBpbnNlY3VyZTogdHJ1ZSxcclxuICAgKiAgIH0pO1xyXG4gICAqXHJcbiAgICogICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XHJcbiAgICogICAgIHJldHVybiByZXNwb25zZS5nZXRCb2R5KHVuZGVmaW5lZCk7XHJcbiAgICogICB9XHJcbiAgICogICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAqIH0pKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBzdGF0aWMgZmV0Y2hQYWNrYWdlQnkoXHJcbiAgICBhY2Nlc3NNb2RlbDogV3JpdGFibGVBY2Nlc3NNb2RlbCxcclxuICAgIGZldGNoZXI6IChwYXRoOiBQYWNrYWdlU3BlYywgZGVmYXVsdEh0dHBVcmw6IHN0cmluZykgPT4gVWludDhBcnJheSB8IHVuZGVmaW5lZCxcclxuICApOiBUeXBzdFNuaXBwZXRQcm92aWRlciB7XHJcbiAgICBjbGFzcyBIdHRwUGFja2FnZVJlZ2lzdHJ5IGV4dGVuZHMgRmV0Y2hQYWNrYWdlUmVnaXN0cnkge1xyXG4gICAgICBwdWxsUGFja2FnZURhdGEocGF0aDogUGFja2FnZVNwZWMpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICByZXR1cm4gZmV0Y2hlcihwYXRoLCB0aGlzLnJlc29sdmVQYXRoKHBhdGgpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5OiAncGFja2FnZS1yZWdpc3RyeSRsYW1iZGEnLFxyXG4gICAgICBmb3JSb2xlczogWydjb21waWxlciddLFxyXG4gICAgICBwcm92aWRlczogW3dpdGhQYWNrYWdlUmVnaXN0cnkobmV3IEh0dHBQYWNrYWdlUmVnaXN0cnkoYWNjZXNzTW9kZWwpKV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIGNjT3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz47XHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbXBpbGVyIGluaXQgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIGdsb2JhbCBpbnN0YW5jZSB7QGxpbmsgJHR5cHN0fS5cclxuICAgKiBTZWUge0BsaW5rIEluaXRPcHRpb25zfS5cclxuICAgKi9cclxuICBzZXRDb21waWxlckluaXRPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8SW5pdE9wdGlvbnM+KSB7XHJcbiAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ2NvbXBpbGVyJywgdGhpcy5jYyk7XHJcbiAgICB0aGlzLmNjT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgZXhPcHRpb25zOiBQYXJ0aWFsPEluaXRPcHRpb25zPjtcclxuICAvKipcclxuICAgKiBTZXQgcmVuZGVyZXIgaW5pdCBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgZ2xvYmFsIGluc3RhbmNlIHtAbGluayAkdHlwc3R9LlxyXG4gICAqIFNlZSB7QGxpbmsgSW5pdE9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIHNldFJlbmRlcmVySW5pdE9wdGlvbnMob3B0aW9uczogUGFydGlhbDxJbml0T3B0aW9ucz4pIHtcclxuICAgIHRoaXMucmVxdWlyZUlzVW5pbml0aWFsaXplZCgncmVuZGVyZXInLCB0aGlzLmV4KTtcclxuICAgIHRoaXMuZXhPcHRpb25zID0gb3B0aW9ucztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBzaGFyZWQgbWFpbiBmaWxlIHBhdGguXHJcbiAgICovXHJcbiAgc2V0TWFpbkZpbGVQYXRoKHBhdGg6IHN0cmluZykge1xyXG4gICAgdGhpcy5tYWluRmlsZVBhdGggPSBwYXRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNoYXJlZCBtYWluIGZpbGUgcGF0aC5cclxuICAgKi9cclxuICBnZXRNYWluRmlsZVBhdGgoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYWluRmlsZVBhdGg7XHJcbiAgfVxyXG5cclxuICByZW1vdmVUbXAob3B0czogQ29tcGlsZU9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmIChvcHRzLm1haW5GaWxlUGF0aC5zdGFydHNXaXRoKCcvdG1wLycpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnVubWFwU2hhZG93KG9wdHMubWFpbkZpbGVQYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgZm9udCB0byB0aGUgY29tcGlsZXIuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IGZvbnRzID0gYXdhaXQgZmV0Y2goJ2ZvbnRJbmZvLmpzb24nKS50aGVuKHJlcyA9PiByZXMuanNvbigpKTtcclxuICAgKiAkdHlwc3QuYWRkRm9udHMoZm9udHMubWFwKGZvbnQgPT4gJHR5cHN0LmxvYWRGb250KGZvbnQudXJsKSkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGZvbnRJbmZvcyB0aGUgZm9udCBpbmZvcyB0byBhZGQuXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0Rm9udHMoZm9udEluZm9zOiBTd2VldExhenlGb250W10pIHtcclxuICAgIGNvbnN0IGZiID0gYXdhaXQgdGhpcy5nZXRGb250UmVzb2x2ZXIoKTtcclxuICAgIGZvciAoY29uc3QgZm9udCBvZiBmb250SW5mb3MpIHtcclxuICAgICAgYXdhaXQgZmIuYWRkTGF6eUZvbnQoZm9udCwgJ2Jsb2InIGluIGZvbnQgPyBmb250LmJsb2IgOiBsb2FkRm9udFN5bmMoZm9udCksIGZvbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29tcGlsZXIgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVyKCk7XHJcbiAgICBhd2FpdCBmYi5idWlsZChhc3luYyBmb250cyA9PiBjb21waWxlci5zZXRGb250cyhmb250cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc291cmNlIGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNhZGRTb3VyY2V9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGFkZFNvdXJjZShwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSkuYWRkU291cmNlKHBhdGgsIGNvbnRlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHNoYWRvdyBmaWxlcy5cclxuICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGlzIGluZGVwZW5kZW50IHRvIHRoZSB7QGxpbmsgcmVzZXR9IGZ1bmN0aW9uLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNyZXNldFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgcmVzZXRTaGFkb3coKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS5yZXNldFNoYWRvdygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2hhZG93IGZpbGUgdG8gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNtYXBTaGFkb3d9LlxyXG4gICAqL1xyXG4gIGFzeW5jIG1hcFNoYWRvdyhwYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IFVpbnQ4QXJyYXkpIHtcclxuICAgIChhd2FpdCB0aGlzLmdldENvbXBpbGVyKCkpLm1hcFNoYWRvdyhwYXRoLCBjb250ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIHNoYWRvdyBmaWxlIGZyb20gdGhlIGNvbXBpbGVyLlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciN1bm1hcFNoYWRvd30uXHJcbiAgICovXHJcbiAgYXN5bmMgdW5tYXBTaGFkb3cocGF0aDogc3RyaW5nKSB7XHJcbiAgICAoYXdhaXQgdGhpcy5nZXRDb21waWxlcigpKS51bm1hcFNoYWRvdyhwYXRoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBpbGUgdGhlIGRvY3VtZW50IHRvIHZlY3RvciAoSVIpIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0Q29tcGlsZU9wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIHZlY3RvcihvPzogU3dlZXRDb21waWxlT3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICBjb25zdCBjb21waWxlciA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXJSZXNldCgpO1xyXG4gICAgcmV0dXJuIGNvbXBpbGVyXHJcbiAgICAgIC5jb21waWxlKG9wdHMpXHJcbiAgICAgIC50aGVuKHJlcyA9PiByZXMucmVzdWx0KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byBQREYgZm9ybWF0LlxyXG4gICAqIFNlZSB7QGxpbmsgU3dlZXRDb21waWxlT3B0aW9uc30uXHJcbiAgICovXHJcbiAgYXN5bmMgcGRmKG8/OiBTd2VldENvbXBpbGVPcHRpb25zKSB7XHJcbiAgICBjb25zdCBvcHRzID0gYXdhaXQgdGhpcy5nZXRDb21waWxlT3B0aW9ucyhvKTtcclxuICAgIG9wdHMuZm9ybWF0ID0gQ29tcGlsZUZvcm1hdEVudW0ucGRmO1xyXG4gICAgY29uc3QgY29tcGlsZXIgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVyUmVzZXQoKTtcclxuICAgIHJldHVybiBjb21waWxlclxyXG4gICAgICAuY29tcGlsZShvcHRzKVxyXG4gICAgICAudGhlbihyZXMgPT4gcmVzLnJlc3VsdClcclxuICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5yZW1vdmVUbXAob3B0cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcGlsZSB0aGUgZG9jdW1lbnQgdG8gU1ZHIGZvcm1hdC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJTdmdPcHRpb25zfS5cclxuICAgKi9cclxuICBhc3luYyBzdmcobz86IFN3ZWV0UmVuZGVyT3B0aW9ucyAmIFJlbmRlclN2Z09wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclN2Zyh7XHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21waWxlIHRoZSBkb2N1bWVudCB0byBjYW52YXMgb3BlcmF0aW9ucy5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0UmVuZGVyT3B0aW9uc30gYW5kIHtAbGluayBSZW5kZXJUb0NhbnZhc09wdGlvbnN9LlxyXG4gICAqL1xyXG4gIGFzeW5jIGNhbnZhcyhcclxuICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICBvPzogU3dlZXRSZW5kZXJPcHRpb25zICYgT21pdDxSZW5kZXJUb0NhbnZhc09wdGlvbnMsICdjb250YWluZXInPixcclxuICApIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zaWVudFJlbmRlcihvLCAocmVuZGVyZXIsIHJlbmRlclNlc3Npb24pID0+XHJcbiAgICAgIHJlbmRlcmVyLnJlbmRlclRvQ2FudmFzKHtcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICByZW5kZXJTZXNzaW9uLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgc2VtYW50aWMgdG9rZW5zIGZvciB0aGUgZG9jdW1lbnQuXHJcbiAgICovXHJcbiAgYXN5bmMgcXVlcnk8VD4obzogU3dlZXRDb21waWxlT3B0aW9ucyAmIHsgc2VsZWN0b3I6IHN0cmluZzsgZmllbGQ/OiBzdHJpbmcgfSk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICBjb25zdCBjb21waWxlciA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXJSZXNldCgpO1xyXG4gICAgcmV0dXJuIGNvbXBpbGVyXHJcbiAgICAgIC5xdWVyeTxUPih7XHJcbiAgICAgICAgLi4ubyxcclxuICAgICAgICAuLi5vcHRzLFxyXG4gICAgICB9KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdG9rZW4gbGVnZW5kIGZvciBzZW1hbnRpYyB0b2tlbnMuXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U2VtYW50aWNUb2tlbkxlZ2VuZCgpOiBQcm9taXNlPFNlbWFudGljVG9rZW5zTGVnZW5kPiB7XHJcbiAgICBjb25zdCBjb21waWxlciA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXJSZXNldCgpO1xyXG4gICAgcmV0dXJuIGNvbXBpbGVyLmdldFNlbWFudGljVG9rZW5MZWdlbmQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBzZW1hbnRpYyB0b2tlbnMgZm9yIHRoZSBkb2N1bWVudC5cclxuICAgKiBTZWUge0BsaW5rIFN3ZWV0Q29tcGlsZU9wdGlvbnN9LlxyXG4gICAqIFNlZSB7QGxpbmsgVHlwc3RDb21waWxlciNnZXRTZW1hbnRpY1Rva2Vuc30uXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U2VtYW50aWNUb2tlbnMobzogU3dlZXRDb21waWxlT3B0aW9ucyAmIHsgcmVzdWx0SWQ/OiBzdHJpbmcgfSk6IFByb21pc2U8U2VtYW50aWNUb2tlbnM+IHtcclxuICAgIGNvbnN0IG9wdHMgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVPcHRpb25zKG8pO1xyXG4gICAgY29uc3QgY29tcGlsZXIgPSBhd2FpdCB0aGlzLmdldENvbXBpbGVyUmVzZXQoKTtcclxuICAgIHJldHVybiBjb21waWxlclxyXG4gICAgICAuZ2V0U2VtYW50aWNUb2tlbnMoe1xyXG4gICAgICAgIG1haW5GaWxlUGF0aDogb3B0cy5tYWluRmlsZVBhdGgsXHJcbiAgICAgICAgcmVzdWx0SWQ6IG8ucmVzdWx0SWQsXHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMucmVtb3ZlVG1wKG9wdHMpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q29tcGlsZU9wdGlvbnMoXHJcbiAgICBvcHRzPzogU3dlZXRDb21waWxlT3B0aW9ucyxcclxuICApOiBQcm9taXNlPENvbXBpbGVPcHRpb25zPENvbXBpbGVGb3JtYXRFbnVtLCAnbm9uZSc+PiB7XHJcbiAgICBpZiAob3B0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB7IG1haW5GaWxlUGF0aDogdGhpcy5tYWluRmlsZVBhdGgsIGRpYWdub3N0aWNzOiAnbm9uZScgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGxlYXNlIHNwZWNpZnkgb3B0cyBhcyB7bWFpbkNvbnRlbnQ6ICcuLi4nfSBvciB7bWFpbkZpbGVQYXRoOiAnLi4uJ31gKTtcclxuICAgIH0gZWxzZSBpZiAoJ21haW5GaWxlUGF0aCcgaW4gb3B0cykge1xyXG4gICAgICByZXR1cm4geyAuLi5vcHRzLCBkaWFnbm9zdGljczogJ25vbmUnIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBkZXN0RmlsZSA9IGAvdG1wLyR7cmFuZHN0cigpfS50eXBgO1xyXG4gICAgICBhd2FpdCB0aGlzLmFkZFNvdXJjZShkZXN0RmlsZSwgb3B0cy5tYWluQ29udGVudCk7XHJcbiAgICAgIHJldHVybiB7IG1haW5GaWxlUGF0aDogZGVzdEZpbGUsIGlucHV0czogb3B0cy5pbnB1dHMsIGRpYWdub3N0aWNzOiAnbm9uZScgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZ2V0VmVjdG9yKG8/OiBTd2VldFJlbmRlck9wdGlvbnMpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgIGlmIChvICYmICd2ZWN0b3JEYXRhJyBpbiBvKSB7XHJcbiAgICAgIHJldHVybiBvLnZlY3RvckRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IGF3YWl0IHRoaXMuZ2V0Q29tcGlsZU9wdGlvbnMobyk7XHJcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0Q29tcGlsZXIoKSlcclxuICAgICAgLmNvbXBpbGUob3B0cylcclxuICAgICAgLnRoZW4ocmVzID0+IHJlcy5yZXN1bHQhKVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLnJlbW92ZVRtcChvcHRzKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHRyYW5zaWVudFJlbmRlcjxUPihcclxuICAgIG9wdHM6IFN3ZWV0UmVuZGVyT3B0aW9ucyB8IHVuZGVmaW5lZCxcclxuICAgIGY6IChycjogVHlwc3RSZW5kZXJlciwgc2Vzc2lvbjogUmVuZGVyU2Vzc2lvbikgPT4gVCxcclxuICApOiBQcm9taXNlPFQ+IHtcclxuICAgIGNvbnN0IHJyID0gYXdhaXQgdGhpcy5nZXRSZW5kZXJlcigpO1xyXG4gICAgaWYgKCFycikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvZXMgbm90IHByb3ZpZGUgcmVuZGVyZXIgaW5zdGFuY2UnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFZlY3RvcihvcHRzKTtcclxuICAgIHJldHVybiBhd2FpdCByci5ydW5XaXRoU2Vzc2lvbihhc3luYyBzZXNzaW9uID0+IHtcclxuICAgICAgcnIubWFuaXB1bGF0ZURhdGEoe1xyXG4gICAgICAgIHJlbmRlclNlc3Npb246IHNlc3Npb24sXHJcbiAgICAgICAgYWN0aW9uOiAncmVzZXQnLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gZihyciwgc2Vzc2lvbik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByZXBhcmVVc2VPbmNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gIHByaXZhdGUgYXN5bmMgcHJlcGFyZVVzZSgpIHtcclxuICAgIGlmICh0aGlzLnByZXBhcmVVc2VPbmNlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByZXBhcmVVc2VPbmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh0aGlzLnByZXBhcmVVc2VPbmNlID0gdGhpcy5kb1ByZXBhcmVVc2UoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGRvUHJlcGFyZVVzZSgpIHtcclxuICAgIGlmICghdGhpcy5wcm92aWRlcnMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb3ZpZGVycyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICB0aGlzLnByb3ZpZGVycy5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdmdW5jdGlvbicgPyBwKCkgOiBwKSksXHJcbiAgICApO1xyXG4gICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcclxuXHJcbiAgICBpZiAoXHJcbiAgICAgICR0eXBzdCA9PSB0aGlzICYmXHJcbiAgICAgICFwcm92aWRlcnMuc29tZShwID0+IHAua2V5LmluY2x1ZGVzKCdwYWNrYWdlLXJlZ2lzdHJ5JykgfHwgcC5rZXkuaW5jbHVkZXMoJ2FjY2Vzcy1tb2RlbCcpKVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIE5vdGU6IHRoZSBkZWZhdWx0IGZldGNoIGJhY2tlbmQgYWx3YXlzIGFkZHMgYSB3aXRoQWNjZXNzTW9kZWwobWVtKVxyXG4gICAgICBpZiAoaXNOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZXNjYXBlSW1wb3J0ID0gbmV3IEZ1bmN0aW9uKCdtJywgJ3JldHVybiBpbXBvcnQobSknKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgbSA9IG5ldyBNZW1vcnlBY2Nlc3NNb2RlbCgpO1xyXG4gICAgICAgICAgY29uc3QgeyBkZWZhdWx0OiByZXF1ZXN0IH0gPSBhd2FpdCBlc2NhcGVJbXBvcnQoJ3N5bmMtcmVxdWVzdCcpO1xyXG5cclxuICAgICAgICAgICR0eXBzdC51c2UoXHJcbiAgICAgICAgICAgIFR5cHN0U25pcHBldC53aXRoQWNjZXNzTW9kZWwobSksXHJcbiAgICAgICAgICAgIFR5cHN0U25pcHBldC5mZXRjaFBhY2thZ2VCeShtLCAoXzogdW5rbm93biwgcGF0aDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0KCdHRVQnLCBwYXRoKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmdldEJvZHkodW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICR0eXBzdC51c2UoVHlwc3RTbmlwcGV0LmZldGNoUGFja2FnZVJlZ2lzdHJ5KCkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcHJvdmlkZXJzMiA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICB0aGlzLnByb3ZpZGVycy5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdmdW5jdGlvbicgPyBwKCkgOiBwKSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNjT3B0aW9ucyA9ICh0aGlzLmNjT3B0aW9ucyB8fD0ge30pO1xyXG4gICAgY29uc3QgY2NCZWZvcmVCdWlsZCA9IChjY09wdGlvbnMuYmVmb3JlQnVpbGQgfHw9IFtdKTtcclxuXHJcbiAgICBjb25zdCBleE9wdGlvbnMgPSAodGhpcy5leE9wdGlvbnMgfHw9IHt9KTtcclxuICAgIGNvbnN0IGV4QmVmb3JlQnVpbGQgPSAoZXhPcHRpb25zLmJlZm9yZUJ1aWxkIHx8PSBbXSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBbLi4ucHJvdmlkZXJzLCAuLi5wcm92aWRlcnMyXSkge1xyXG4gICAgICBpZiAocHJvdmlkZXIuZm9yUm9sZXMuaW5jbHVkZXMoJ2NvbXBpbGVyJykpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ2NvbXBpbGVyJywgdGhpcy5jYyk7XHJcbiAgICAgICAgY2NCZWZvcmVCdWlsZC5wdXNoKC4uLnByb3ZpZGVyLnByb3ZpZGVzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvdmlkZXIuZm9yUm9sZXMuaW5jbHVkZXMoJ3JlbmRlcmVyJykpIHtcclxuICAgICAgICB0aGlzLnJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQoJ3JlbmRlcmVyJywgdGhpcy5leCk7XHJcbiAgICAgICAgZXhCZWZvcmVCdWlsZC5wdXNoKC4uLnByb3ZpZGVyLnByb3ZpZGVzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5wcm92aWRlcnMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlcXVpcmVJc1VuaW5pdGlhbGl6ZWQ8VD4ocm9sZTogc3RyaW5nLCBjOiBQcm9taXNlSnVzdDxUPiwgZT86IFByb21pc2VKdXN0PFQ+KSB7XHJcbiAgICBpZiAoYyAmJiB0eXBlb2YgYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cm9sZX0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQ6ICR7Y31gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgYXN5bmMgYnVpbGRMb2NhbENvbXBpbGVyKHRoaXM6IFR5cHN0U25pcHBldCkge1xyXG4gICAgY29uc3QgeyBjcmVhdGVUeXBzdENvbXBpbGVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9jb21waWxlcidcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9jb21waWxlci5tanMnKTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnByZXBhcmVVc2UoKTtcclxuICAgIGNvbnN0IGNvbXBpbGVyID0gY3JlYXRlVHlwc3RDb21waWxlcigpO1xyXG4gICAgYXdhaXQgY29tcGlsZXIuaW5pdCh0aGlzLmNjT3B0aW9ucyk7XHJcbiAgICByZXR1cm4gY29tcGlsZXI7XHJcbiAgfVxyXG5cclxuICAvKiogQGludGVybmFsICovXHJcbiAgc3RhdGljIGFzeW5jIGJ1aWxkTG9jYWxGb250UmVzb2x2ZXIodGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0Rm9udEJ1aWxkZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL2NvbXBpbGVyJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4uL2NvbXBpbGVyLm1qcycpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVVzZSgpO1xyXG4gICAgY29uc3QgZm9udHMgPSBjcmVhdGVUeXBzdEZvbnRCdWlsZGVyKCk7XHJcbiAgICBhd2FpdCBmb250cy5pbml0KHRoaXMuY2NPcHRpb25zKTtcclxuICAgIHJldHVybiBmb250cztcclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgYXN5bmMgYnVpbGRHbG9iYWxDb21waWxlcih0aGlzOiBUeXBzdFNuaXBwZXQpIHtcclxuICAgIC8vIGxhenkgaW1wb3J0IGNvbXBpbGUgbW9kdWxlXHJcbiAgICBjb25zdCB7IGNyZWF0ZUdsb2JhbENvbXBpbGVyIH0gPSAoYXdhaXQgaW1wb3J0KFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICdAbXlyaWFkZHJlYW1pbi90eXBzdC50cy9jb250cmliL2dsb2JhbC1jb21waWxlcidcclxuICAgICkpIGFzIGFueSBhcyB0eXBlb2YgaW1wb3J0KCcuL2dsb2JhbC1jb21waWxlci5tanMnKTtcclxuICAgIGNvbnN0IHsgY3JlYXRlVHlwc3RDb21waWxlciB9ID0gKGF3YWl0IGltcG9ydChcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAnQG15cmlhZGRyZWFtaW4vdHlwc3QudHMvY29tcGlsZXInXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi4vY29tcGlsZXIubWpzJyk7XHJcblxyXG4gICAgYXdhaXQgdGhpcy5wcmVwYXJlVXNlKCk7XHJcbiAgICByZXR1cm4gY3JlYXRlR2xvYmFsQ29tcGlsZXIoY3JlYXRlVHlwc3RDb21waWxlciwgdGhpcy5jY09wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBhc3luYyBidWlsZExvY2FsUmVuZGVyZXIodGhpczogVHlwc3RTbmlwcGV0KSB7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0UmVuZGVyZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL3JlbmRlcmVyJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlbmRlcmVyLm1qcycpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVVzZSgpO1xyXG4gICAgY29uc3QgcmVuZGVyZXIgPSBjcmVhdGVUeXBzdFJlbmRlcmVyKCk7XHJcbiAgICBhd2FpdCByZW5kZXJlci5pbml0KHRoaXMuZXhPcHRpb25zKTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxuICB9XHJcblxyXG4gIC8qKiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgYXN5bmMgYnVpbGRHbG9iYWxSZW5kZXJlcih0aGlzOiBUeXBzdFNuaXBwZXQpIHtcclxuICAgIC8vIGxhenkgaW1wb3J0IHJlbmRlcmVyIG1vZHVsZVxyXG4gICAgY29uc3QgeyBjcmVhdGVHbG9iYWxSZW5kZXJlciB9ID0gKGF3YWl0IGltcG9ydChcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAnQG15cmlhZGRyZWFtaW4vdHlwc3QudHMvY29udHJpYi9nbG9iYWwtcmVuZGVyZXInXHJcbiAgICApKSBhcyBhbnkgYXMgdHlwZW9mIGltcG9ydCgnLi9nbG9iYWwtcmVuZGVyZXIubWpzJyk7XHJcbiAgICBjb25zdCB7IGNyZWF0ZVR5cHN0UmVuZGVyZXIgfSA9IChhd2FpdCBpbXBvcnQoXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgJ0BteXJpYWRkcmVhbWluL3R5cHN0LnRzL3JlbmRlcmVyJ1xyXG4gICAgKSkgYXMgYW55IGFzIHR5cGVvZiBpbXBvcnQoJy4uL3JlbmRlcmVyLm1qcycpO1xyXG5cclxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVVzZSgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZUdsb2JhbFJlbmRlcmVyKGNyZWF0ZVR5cHN0UmVuZGVyZXIsIHRoaXMuZXhPcHRpb25zKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgbGF6eSBpbml0aWFsaXplZCBnbG9iYWwgc2hhcmVkIGluc3RhbmNlIG9mIHtAbGluayBUeXBzdFNuaXBwZXR9LiBTZWVcclxuICoge0BsaW5rIFR5cHN0U25pcHBldH0gZm9yIG1vcmUgZGV0YWlscy5cclxuICovXHJcbmV4cG9ydCBjb25zdCAkdHlwc3QgPSBuZXcgVHlwc3RTbmlwcGV0KHtcclxuICBjb21waWxlcjogVHlwc3RTbmlwcGV0LmJ1aWxkR2xvYmFsQ29tcGlsZXIsXHJcbiAgcmVuZGVyZXI6IFR5cHN0U25pcHBldC5idWlsZEdsb2JhbFJlbmRlcmVyLFxyXG59KTtcclxuIl19