var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var stdin_exports = {};
__export(stdin_exports, {
  CompileFormatEnum: () => CompileFormatEnum,
  IncrementalServer: () => IncrementalServer,
  TypstFontBuilderDriver: () => TypstFontBuilderDriver,
  TypstWorld: () => TypstWorld,
  createTypstCompiler: () => createTypstCompiler,
  createTypstFontBuilder: () => createTypstFontBuilder
});
module.exports = __toCommonJS(stdin_exports);
var import_init = require("./init.cjs");
var import_internal_types = require("./internal.types.cjs");
var import_options_init = require("./options.init.cjs");
var import_wasm = require("./wasm.cjs");
var CompileFormatEnum;
(function(CompileFormatEnum2) {
  CompileFormatEnum2[CompileFormatEnum2["vector"] = 0] = "vector";
  CompileFormatEnum2[CompileFormatEnum2["pdf"] = 1] = "pdf";
  CompileFormatEnum2[CompileFormatEnum2["_dummy"] = 2] = "_dummy";
})(CompileFormatEnum || (CompileFormatEnum = {}));
class IncrementalServer {
  /**
   * @internal
   */
  [import_internal_types.kObject];
  /**
   * @internal
   */
  constructor(s) {
    this[import_internal_types.kObject] = s;
  }
  /**
   * Reset the incremental server to the initial state.
   */
  reset() {
    this[import_internal_types.kObject].reset();
  }
  /**
   * Return current result.
   */
  current() {
    return this[import_internal_types.kObject].current();
  }
  /**
   * Also attach the debug info to the result.
   */
  setAttachDebugInfo(enable) {
    this[import_internal_types.kObject].set_attach_debug_info(enable);
  }
}
var TypstFontResolverCons;
/* @__PURE__ */ (function(TypstFontResolverCons2) {
})(TypstFontResolverCons || (TypstFontResolverCons = {}));
function createTypstFontBuilder() {
  return new TypstFontBuilderDriver();
}
class TypstWorld {
  [import_internal_types.kObject];
  constructor(world) {
    this[import_internal_types.kObject] = world;
  }
  /**
   * Compile the paged document.
   *
   * @param {DiagnosticsFormat} format - The format of the diagnostics.
   * @returns {Promise<{ diagnostics?: DiagnosticsData[DiagnosticsFormat][] }>} - The result of the compilation.
   */
  compile(opts) {
    return this[import_internal_types.kObject].compile(0, getDiagnosticsArg(opts?.diagnostics));
  }
  /**
   * Compile the paged document.
   *
   * @param {DiagnosticsFormat} format - The format of the diagnostics.
   * @returns {Promise<{ diagnostics?: DiagnosticsData[DiagnosticsFormat][] }>} - The result of the compilation.
   */
  compileHtml(opts) {
    return this[import_internal_types.kObject].compile(1, getDiagnosticsArg(opts?.diagnostics));
  }
  /**
   * Runs query on the paged document.
   */
  async query(options) {
    return JSON.parse(this[import_internal_types.kObject].query(0, options.selector, options.field));
  }
  /**
   * Get the title of the paged document.
   * Throw error if the world didn't compile the paged document.
   *
   * @returns {string | undefined} - The title of the paged document.
   */
  title() {
    return this[import_internal_types.kObject].title(0);
  }
  /**
   * Export the paged document as vector format.
   *
   * @returns {Uint8Array | undefined} - The title of the paged document.
   */
  vector(opts) {
    return this[import_internal_types.kObject].get_artifact(0, getDiagnosticsArg(opts?.diagnostics)) || {};
  }
  /**
   * Export the paged document to PDF.
   *
   * @returns {Uint8Array | undefined} - The title of the paged document.
   */
  pdf(opts) {
    return this[import_internal_types.kObject].get_artifact(1, getDiagnosticsArg(opts?.diagnostics)) || {};
  }
}
const gCompilerModule = (module2) => new import_wasm.LazyWasmModule(async (bin) => {
  return await module2.default(bin);
});
function createTypstCompiler() {
  return new TypstCompilerDriver();
}
class TypstFontBuilderDriver {
  fontBuilderJs;
  fontBuilder;
  async init(options) {
    this.fontBuilderJs = await (options?.getWrapper?.() || import("@myriaddreamin/typst-ts-web-compiler"));
    await gCompilerModule(this.fontBuilderJs).init(options?.getModule?.());
    this.fontBuilder = new this.fontBuilderJs.TypstFontResolverBuilder();
  }
  async getFontInfo(font_buffer) {
    return this.fontBuilder.get_font_info(font_buffer);
  }
  async addFontData(font_buffer) {
    this.fontBuilder.add_raw_font(font_buffer);
  }
  async addLazyFont(info, blob) {
    return this.fontBuilder.add_lazy_font(info, blob);
  }
  async build(cb) {
    const fonts = await this.fontBuilder.build();
    const result = await cb(fonts);
    fonts.free();
    return result;
  }
}
class TypstCompilerDriver {
  compiler;
  compilerJs;
  static defaultAssets = ["text"];
  constructor() {
  }
  async init(options) {
    this.compilerJs = await (options?.getWrapper?.() || import("@myriaddreamin/typst-ts-web-compiler"));
    const TypstCompilerBuilder = this.compilerJs.TypstCompilerBuilder;
    const compilerOptions = { ...options || {} };
    const beforeBuild = compilerOptions.beforeBuild ??= [];
    const hasPreloadRemoteFonts = beforeBuild.some((fn) => fn._preloadRemoteFontOptions !== void 0);
    const hasSpecifiedAssets = beforeBuild.some((fn) => fn._preloadRemoteFontOptions?.assets !== void 0);
    const hasDisableAssets = beforeBuild.some((fn) => fn._preloadRemoteFontOptions?.assets === false);
    if (!hasPreloadRemoteFonts || !hasSpecifiedAssets && !hasDisableAssets) {
      beforeBuild.push((0, import_options_init.loadFonts)([], { assets: TypstCompilerDriver.defaultAssets }));
    }
    const hasFontLoader = beforeBuild.some((fn) => fn._kind === "fontLoader");
    if (!hasFontLoader) {
      throw new Error("TypstCompiler: no font loader found, please use font loaders, e.g. loadFonts or preloadSystemFonts");
    }
    this.compiler = await (0, import_init.buildComponent)(options, gCompilerModule(this.compilerJs), TypstCompilerBuilder, {});
  }
  setFonts(fonts) {
    this.compiler.set_fonts(fonts);
  }
  compile(options) {
    return new Promise((resolve) => {
      const world = this.compiler.snapshot(options.root, options.mainFilePath, convertInputs(options.inputs));
      if ("incrementalServer" in options) {
        resolve(world.incr_compile(options.incrementalServer[import_internal_types.kObject], getDiagnosticsArg(options.diagnostics)));
        return;
      }
      resolve(world.get_artifact(options.format || CompileFormatEnum.vector, getDiagnosticsArg(options.diagnostics)));
    });
  }
  async runWithWorld(options, cb) {
    const world = this.compiler.snapshot(options.root, options.mainFilePath, convertInputs(options.inputs));
    let result = await cb(new TypstWorld(world));
    world.free();
    return result;
  }
  query(options) {
    return this.runWithWorld(options, async (world) => {
      return JSON.parse(await world.query(options));
    });
  }
  getSemanticTokenLegend() {
    return new Promise((resolve) => {
      resolve(this.compiler.get_semantic_token_legend());
    });
  }
  getSemanticTokens(opts) {
    return new Promise((resolve) => {
      this.compiler.reset();
      resolve(this.compiler.get_semantic_tokens(opts.offsetEncoding || "utf-16", opts.mainFilePath, opts.resultId));
    });
  }
  async withIncrementalServer(f) {
    const srv = new IncrementalServer(this.compiler.create_incr_server());
    try {
      return await f(srv);
    } finally {
      srv[import_internal_types.kObject].free();
    }
  }
  async getAst(mainFilePath) {
    return this.compiler.get_ast(mainFilePath);
  }
  async reset() {
    await new Promise((resolve) => {
      this.compiler.reset();
      resolve(void 0);
    });
  }
  addSource(path, source) {
    if (arguments.length > 2) {
      throw new Error("use of addSource(path, source, isMain) is deprecated, please use addSource(path, source) instead");
    }
    this.compiler.add_source(path, source);
  }
  mapShadow(path, content) {
    this.compiler.map_shadow(path, content);
  }
  unmapShadow(path) {
    this.compiler.unmap_shadow(path);
  }
  resetShadow() {
    this.compiler.reset_shadow();
  }
  renderPageToCanvas() {
    throw new Error("Please use the api TypstRenderer.renderToCanvas in v0.4.0");
  }
}
createTypstCompiler._impl = TypstCompilerDriver;
function convertInputs(inputs) {
  return inputs ? Object.entries(inputs) : void 0;
}
function getDiagnosticsArg(diagnostics) {
  switch (diagnostics) {
    case "none":
      return 1;
    case "unix":
      return 2;
    case "full":
    default:
      return 3;
  }
}
